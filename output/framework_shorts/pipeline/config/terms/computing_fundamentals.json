{
  "category": "computing_fundamentals",
  "category_display": "Computing Fundamentals",
  "description": "Core concepts of how digital systems actually work",
  "terms": [
    {
      "id": "compaction",
      "name": "Compaction",
      "complexity": "simple",
      "duration": 20,
      "definition": "Reorganizing data to eliminate fragmentation",
      "hook": "Your hard drive is like a messy desk. When you delete files, you leave gaps.",
      "explanation": "Compaction reorganizes data to eliminate those gaps, putting everything together. Think defragmentation, but for databases and memory too.",
      "example": "The result? Faster access, less wasted space. It's digital Marie Kondo.",
      "why_matters": "Faster access, less wasted space",
      "on_screen_text": "Compaction = Reorganizing data to eliminate fragmentation",
      "analogies": ["messy desk", "Marie Kondo for data"],
      "related_terms": ["bit_rot", "sharding"],
      "visual_style": "before_after",
      "ascii_scenes": ["scattered_files", "arrow", "organized_files"]
    },
    {
      "id": "idempotency",
      "name": "Idempotency",
      "complexity": "medium",
      "duration": 25,
      "definition": "Operation that produces same result if repeated",
      "hook": "Idempotency means you can do something multiple times and get the same result.",
      "explanation": "Like a light switch - flip it to 'on' 100 times, light stays on. Critical for APIs and databases.",
      "example": "If your payment button isn't idempotent, clicking twice charges you twice. That's bad.",
      "why_matters": "Idempotent systems are safe to retry",
      "on_screen_text": "Idempotency = Same action, same result, every time",
      "analogies": ["light switch", "power button"],
      "related_terms": ["race_condition", "stateless"],
      "visual_style": "demonstration",
      "ascii_scenes": ["cow_pressing_button", "result_constant", "safe_retry"]
    },
    {
      "id": "race_condition",
      "name": "Race Condition",
      "complexity": "complex",
      "duration": 30,
      "definition": "Timing-dependent bug in concurrent systems",
      "hook": "Two processes read your bank balance: $100. Both try to withdraw $60 at the exact same time.",
      "explanation": "Both see $100, both withdraw, both write back $40. You just withdrew $120 from a $100 account.",
      "example": "That's a race condition - when timing determines if your code works. They're sneaky, hard to reproduce, and can cost millions.",
      "why_matters": "The fix? Locks, or atomic operations",
      "on_screen_text": "Race Condition = Timing-dependent bugs in concurrent systems",
      "analogies": ["two people grabbing last cookie"],
      "related_terms": ["idempotency", "eventual_consistency"],
      "visual_style": "problem_demonstration",
      "ascii_scenes": ["two_cows_reading", "simultaneous_withdraw", "wrong_result"]
    },
    {
      "id": "eventual_consistency",
      "name": "Eventual Consistency",
      "complexity": "medium",
      "duration": 25,
      "definition": "System becomes consistent over time, not immediately",
      "hook": "You update your profile pic. Your friend sees the old one for 30 seconds.",
      "explanation": "That's eventual consistency - the system will sync... eventually. Not instantly, but soon.",
      "example": "It's the tradeoff distributed systems make for speed. Amazon, Twitter, Instagram all use this.",
      "why_matters": "Consistency isn't instant, but it's fast enough",
      "on_screen_text": "Eventual Consistency = Data syncs over time, not immediately",
      "analogies": ["gossip spreading through group"],
      "related_terms": ["race_condition", "sharding"],
      "visual_style": "process",
      "ascii_scenes": ["server_update", "propagation", "all_synced"]
    },
    {
      "id": "cache_invalidation",
      "name": "Cache Invalidation",
      "complexity": "medium",
      "duration": 25,
      "definition": "Knowing when to refresh stored data",
      "hook": "Phil Karlton said: 'There are only two hard things in Computer Science: cache invalidation and naming things.'",
      "explanation": "A cache stores data for quick access. But when does stale data become wrong data?",
      "example": "Refresh too often, cache is useless. Too rare, users see old info.",
      "why_matters": "Getting this timing right is genuinely one of computing's hardest problems",
      "on_screen_text": "Cache Invalidation = Knowing when to refresh stored data",
      "analogies": ["checking milk expiration date"],
      "related_terms": ["compaction", "eventual_consistency"],
      "visual_style": "problem_demonstration",
      "ascii_scenes": ["cached_data", "reality_changes", "when_to_update"]
    },
    {
      "id": "sharding",
      "name": "Sharding",
      "complexity": "simple",
      "duration": 20,
      "definition": "Splitting database across multiple machines",
      "hook": "Your database is too big for one machine. Solution? Sharding - split it across multiple servers.",
      "explanation": "Users A-M on server 1, N-Z on server 2. Each 'shard' is independent.",
      "example": "Instagram, Facebook, Twitter all shard by user.",
      "why_matters": "The tradeoff? Queries across shards get complicated",
      "on_screen_text": "Sharding = Splitting database across multiple machines",
      "analogies": ["filing cabinets in different rooms"],
      "related_terms": ["eventual_consistency"],
      "visual_style": "before_after",
      "ascii_scenes": ["one_big_db", "split_arrow", "multiple_shards"]
    },
    {
      "id": "latency_throughput",
      "name": "Latency vs Throughput",
      "complexity": "complex",
      "duration": 30,
      "definition": "Response time vs total capacity",
      "hook": "Latency is how fast. Throughput is how much.",
      "explanation": "A sports car has low latency - arrives quickly. But carries one person. A bus has high latency - takes longer. But carries 50 people - high throughput.",
      "example": "Your internet: ping is latency, bandwidth is throughput. For video calls, you need low latency. For downloads, you need high throughput.",
      "why_matters": "Different problems, different solutions",
      "on_screen_text": "Latency = Response time | Throughput = Total capacity",
      "analogies": ["sports car vs bus"],
      "related_terms": ["sharding"],
      "visual_style": "comparison",
      "ascii_scenes": ["sports_car", "vs", "bus"]
    },
    {
      "id": "stateless_stateful",
      "name": "Stateless vs Stateful",
      "complexity": "medium",
      "duration": 25,
      "definition": "Whether system remembers previous interactions",
      "hook": "Stateless systems don't remember you. Every request starts fresh. Like talking to someone with amnesia.",
      "explanation": "Stateful systems remember - session, shopping cart, login.",
      "example": "Stateless scales easily - any server can handle any request. Stateful is complex - that server knows your history.",
      "why_matters": "Modern apps? Often stateless servers with stateful databases",
      "on_screen_text": "Stateless = No memory | Stateful = Remembers context",
      "analogies": ["person with amnesia vs friend"],
      "related_terms": ["idempotency"],
      "visual_style": "comparison",
      "ascii_scenes": ["stateless_cow", "vs", "stateful_cow"]
    },
    {
      "id": "technical_debt",
      "name": "Technical Debt",
      "complexity": "medium",
      "duration": 25,
      "definition": "Future cost of choosing quick solutions now",
      "hook": "Technical debt is choosing fast over right. Need a feature today? Hack it together.",
      "explanation": "But like financial debt, you pay interest - slower development, more bugs, harder changes.",
      "example": "Eventually, the interest is crushing. The solution? Sometimes you need debt to ship. But you must pay it down, or it compounds.",
      "why_matters": "Code bankruptcy is a full rewrite",
      "on_screen_text": "Technical Debt = Future cost of quick solutions today",
      "analogies": ["credit card debt"],
      "related_terms": ["abstraction_leak", "premature_optimization"],
      "visual_style": "process",
      "ascii_scenes": ["quick_fix", "debt_accumulates", "crushing_interest"]
    },
    {
      "id": "abstraction_leak",
      "name": "Abstraction Leak",
      "complexity": "medium",
      "duration": 25,
      "definition": "When implementation details break through interface",
      "hook": "Abstractions hide complexity. You don't think about engine pistons when driving.",
      "explanation": "But when abstractions leak, implementation details break through.",
      "example": "An app says 'Save failed' - that's fine. But 'PostgreSQL connection timeout on port 5432'? That's leaking.",
      "why_matters": "Good abstractions hide irrelevant details. Leaky abstractions force you to understand what you were trying to hide",
      "on_screen_text": "Abstraction Leak = Implementation details break through interface",
      "analogies": ["seeing engine through car hood"],
      "related_terms": ["technical_debt"],
      "visual_style": "problem_demonstration",
      "ascii_scenes": ["clean_interface", "crack", "implementation_visible"]
    },
    {
      "id": "endianness",
      "name": "Byte Order (Endianness)",
      "complexity": "complex",
      "duration": 30,
      "definition": "Byte storage order in multi-byte numbers",
      "hook": "How do you store the number 1,234? Most significant byte first - that's big-endian. Or least significant first - little-endian.",
      "explanation": "It's like reading left-to-right vs right-to-left. Intel uses little-endian. Network protocols use big-endian.",
      "example": "When they talk, you must convert. Get it wrong? Your numbers are gibberish.",
      "why_matters": "This matters for low-level programming, file formats, network communication",
      "on_screen_text": "Endianness = Byte storage order in multi-byte numbers",
      "analogies": ["reading left-to-right vs right-to-left"],
      "related_terms": [],
      "visual_style": "comparison",
      "ascii_scenes": ["big_endian", "vs", "little_endian"]
    },
    {
      "id": "referential_transparency",
      "name": "Referential Transparency",
      "complexity": "medium",
      "duration": 25,
      "definition": "Same input produces same output, always",
      "hook": "A function is referentially transparent if the same inputs always give the same output.",
      "explanation": "add(2, 3) is always 5. But random() is different every time.",
      "example": "Why care? Transparent functions are predictable, testable, cacheable, parallelizable. Functional programming loves this.",
      "why_matters": "The opposite - side effects, randomness, time-dependence - makes code harder to reason about",
      "on_screen_text": "Referential Transparency = Same input â†’ Same output, always",
      "analogies": ["mathematical function"],
      "related_terms": ["idempotency"],
      "visual_style": "comparison",
      "ascii_scenes": ["transparent_function", "vs", "random_function"]
    },
    {
      "id": "bit_rot",
      "name": "Bit Rot",
      "complexity": "simple",
      "duration": 20,
      "definition": "Data degradation over time without changes",
      "hook": "You save a file and never touch it. Years later, it's corrupted. That's bit rot - data degradation without changes.",
      "explanation": "Cosmic rays, magnetic decay, hardware flaws. It's why archivists use error-correcting codes and multiple copies.",
      "example": "Your data isn't safe just because you don't touch it.",
      "why_matters": "Time itself is the enemy",
      "on_screen_text": "Bit Rot = Data degradation over time without changes",
      "analogies": ["paper yellowing", "photograph fading"],
      "related_terms": ["compaction"],
      "visual_style": "process",
      "ascii_scenes": ["pristine_file", "time_passes", "corrupted_file"]
    }
  ]
}
